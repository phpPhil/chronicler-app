import axios, { AxiosError } from 'axios';
import { ChroniclerApiClient } from '../../../services/ChroniclerApiClient';
import { ApiClientConfig, UploadResult, DistanceCalculationResult } from '../../../types/api';

// Use the already mocked axios from setupTests.ts
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('ChroniclerApiClient', () => {
  let apiClient: ChroniclerApiClient;
  let config: ApiClientConfig;

  beforeEach(() => {
    jest.clearAllMocks();
    
    config = {
      baseURL: 'http://localhost:3001',
      timeout: 30000,
      retryAttempts: 3,
      retryDelay: 1000,
      enableLogging: false
    };

    // Mock axios.create to return our mocked axios instance
    mockedAxios.create.mockReturnValue(mockedAxios);
    
    apiClient = new ChroniclerApiClient(config);
  });

  describe('constructor', () => {
    test('creates instance with default config', () => {
      const client = new ChroniclerApiClient();
      expect(client).toBeInstanceOf(ChroniclerApiClient);
    });

    test('creates instance with custom config', () => {
      const customConfig = { ...config, timeout: 60000 };
      const client = new ChroniclerApiClient(customConfig);
      expect(client).toBeInstanceOf(ChroniclerApiClient);
    });

    test('sets up axios instance with correct config', () => {
      // Just verify the client was created successfully
      expect(apiClient).toBeInstanceOf(ChroniclerApiClient);
    });
  });

  describe('uploadFile', () => {
    const mockFile = new File(['1 2\n3 4\n'], 'test.txt', { type: 'text/plain' });
    const mockUploadResult: UploadResult = {
      success: true,
      fileId: 'file-123',
      message: 'File uploaded successfully',
      data: {
        list1: [1, 3],
        list2: [2, 4],
        rowCount: 2
      }
    };

    test('uploads file successfully with progress tracking', async () => {
      const onProgress = jest.fn();
      
      mockedAxios.post.mockResolvedValueOnce({
        data: mockUploadResult,
        status: 200
      });

      const result = await apiClient.uploadFile(mockFile, onProgress);

      expect(mockedAxios.post).toHaveBeenCalledWith(
        '/api/upload',
        expect.any(FormData),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Content-Type': 'multipart/form-data'
          }),
          onUploadProgress: expect.any(Function)
        })
      );
      
      expect(result).toEqual(mockUploadResult);
    });

    test('uploads file successfully without progress tracking', async () => {
      mockedAxios.post.mockResolvedValueOnce({
        data: mockUploadResult,
        status: 200
      });

      const result = await apiClient.uploadFile(mockFile);

      expect(result).toEqual(mockUploadResult);
      expect(mockedAxios.post).toHaveBeenCalledWith(
        '/api/upload',
        expect.any(FormData),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Content-Type': 'multipart/form-data'
          })
        })
      );
    });

    test('handles upload error response', async () => {
      const errorResponse = {
        success: false,
        error: 'File too large'
      };

      mockedAxios.post.mockResolvedValueOnce({
        data: errorResponse,
        status: 400
      });

      const result = await apiClient.uploadFile(mockFile);
      expect(result).toEqual(errorResponse);
    });

    test('handles network error', async () => {
      const networkError = new AxiosError('Network Error');
      networkError.code = 'NETWORK_ERROR';
      
      mockedAxios.post.mockRejectedValueOnce(networkError);

      await expect(apiClient.uploadFile(mockFile)).rejects.toThrow('Network Error');
    });

    test('handles server error', async () => {
      const serverError = new AxiosError('Internal Server Error');
      serverError.response = {
        status: 500,
        data: { error: 'Internal Server Error' },
        statusText: 'Internal Server Error',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.post.mockRejectedValueOnce(serverError);

      await expect(apiClient.uploadFile(mockFile)).rejects.toThrow('Internal Server Error');
    });

    test('calls progress callback during upload', async () => {
      const onProgress = jest.fn();
      
      mockedAxios.post.mockImplementation((url, data, config) => {
        // Simulate progress events
        if (config?.onUploadProgress) {
          config.onUploadProgress({ loaded: 50, total: 100 } as any);
          config.onUploadProgress({ loaded: 100, total: 100 } as any);
        }
        
        return Promise.resolve({
          data: mockUploadResult,
          status: 200
        });
      });

      await apiClient.uploadFile(mockFile, onProgress);

      expect(onProgress).toHaveBeenCalledWith(50);
      expect(onProgress).toHaveBeenCalledWith(100);
    });
  });

  describe('calculateDistance', () => {
    const mockInput = {
      list1: [3, 1, 4],
      list2: [1, 5, 9]
    };

    const mockResult: DistanceCalculationResult = {
      totalDistance: 10,
      pairs: [
        { position: 0, list1Value: 1, list2Value: 1, distance: 0 },
        { position: 1, list1Value: 3, list2Value: 5, distance: 2 },
        { position: 2, list1Value: 4, list2Value: 9, distance: 5 }
      ],
      metadata: {
        originalList1Length: 3,
        originalList2Length: 3,
        processingTimeMs: 1.234
      }
    };

    test('calculates distance successfully', async () => {
      mockedAxios.post.mockResolvedValueOnce({
        data: mockResult,
        status: 200
      });

      const result = await apiClient.calculateDistance(mockInput);

      expect(mockedAxios.post).toHaveBeenCalledWith('/api/distance/calculate', mockInput);
      expect(result).toEqual(mockResult);
    });

    test('handles validation error', async () => {
      const validationError = new AxiosError('Input arrays must have equal length');
      validationError.response = {
        status: 400,
        data: { error: 'Input arrays must have equal length' },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.post.mockRejectedValueOnce(validationError);

      await expect(apiClient.calculateDistance(mockInput)).rejects.toThrow('Input arrays must have equal length');
    });

    test('handles empty arrays', async () => {
      const emptyInput = { list1: [], list2: [] };
      
      mockedAxios.post.mockResolvedValueOnce({
        data: {
          totalDistance: 0,
          pairs: [],
          metadata: {
            originalList1Length: 0,
            originalList2Length: 0,
            processingTimeMs: 0.1
          }
        },
        status: 200
      });

      const result = await apiClient.calculateDistance(emptyInput);
      expect(result.totalDistance).toBe(0);
      expect(result.pairs).toHaveLength(0);
    });
  });

  describe('healthCheck', () => {
    const mockHealthStatus = {
      status: 'healthy' as const,
      timestamp: '2025-07-30T12:00:00Z',
      uptime: 3600
    };

    test('returns health status successfully', async () => {
      mockedAxios.get.mockResolvedValueOnce({
        data: mockHealthStatus,
        status: 200
      });

      const result = await apiClient.healthCheck();

      expect(mockedAxios.get).toHaveBeenCalledWith('/api/health');
      expect(result).toEqual(mockHealthStatus);
    });

    test('handles unhealthy server', async () => {
      const unhealthyStatus = {
        status: 'unhealthy' as const,
        timestamp: '2025-07-30T12:00:00Z',
        uptime: 3600
      };
      
      mockedAxios.get.mockResolvedValueOnce({
        data: unhealthyStatus,
        status: 503
      });

      const result = await apiClient.healthCheck();
      expect(result.status).toBe('unhealthy');
    });

    test('handles server unavailable', async () => {
      const serverError = new AxiosError('Service Unavailable');
      serverError.response = {
        status: 503,
        data: { error: 'Service Unavailable' },
        statusText: 'Service Unavailable',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.get.mockRejectedValueOnce(serverError);

      await expect(apiClient.healthCheck()).rejects.toThrow('Service Unavailable');
    });
  });

  describe('retry mechanism', () => {
    test('retries failed requests with exponential backoff', async () => {
      const networkError = new AxiosError('Network Error');
      networkError.code = 'NETWORK_ERROR';
      
      // First two calls fail, third succeeds
      mockedAxios.get
        .mockRejectedValueOnce(networkError)
        .mockRejectedValueOnce(networkError)
        .mockResolvedValueOnce({
          data: { status: 'healthy', timestamp: '2025-07-30T12:00:00Z', uptime: 3600 },
          status: 200
        });

      const result = await apiClient.healthCheck();
      
      expect(mockedAxios.get).toHaveBeenCalledTimes(3);
      expect(result.status).toBe('healthy');
    });

    test('fails after maximum retry attempts', async () => {
      const networkError = new AxiosError('Network Error');
      networkError.code = 'NETWORK_ERROR';
      
      mockedAxios.get.mockRejectedValue(networkError);

      await expect(apiClient.healthCheck()).rejects.toThrow('Network Error');
      expect(mockedAxios.get).toHaveBeenCalledTimes(4); // Initial + 3 retries
    });

    test('does not retry non-retryable errors', async () => {
      const validationError = new AxiosError('Bad Request');
      validationError.response = {
        status: 400,
        data: { error: 'Bad Request' },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.get.mockRejectedValueOnce(validationError);

      await expect(apiClient.healthCheck()).rejects.toThrow('Bad Request');
      expect(mockedAxios.get).toHaveBeenCalledTimes(1); // No retries for 400 errors
    });
  });

  describe('error handling', () => {
    test('handles network errors correctly', async () => {
      const networkError = new AxiosError('Network Error');
      networkError.code = 'NETWORK_ERROR';
      
      mockedAxios.get.mockRejectedValueOnce(networkError);

      await expect(apiClient.healthCheck()).rejects.toMatchObject({
        code: 'NETWORK_ERROR',
        userMessage: 'Please check your internet connection and try again.',
        retryable: true
      });
    });

    test('handles timeout errors correctly', async () => {
      const timeoutError = new AxiosError('Request timeout');
      timeoutError.code = 'ECONNABORTED';
      
      mockedAxios.get.mockRejectedValueOnce(timeoutError);

      await expect(apiClient.healthCheck()).rejects.toMatchObject({
        code: 'TIMEOUT_ERROR',
        userMessage: 'The request took too long. Please try again.',
        retryable: true
      });
    });

    test('handles server errors correctly', async () => {
      const serverError = new AxiosError('Internal Server Error');
      serverError.response = {
        status: 500,
        data: { error: 'Internal Server Error' },
        statusText: 'Internal Server Error',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.get.mockRejectedValueOnce(serverError);

      await expect(apiClient.healthCheck()).rejects.toMatchObject({
        code: 'SERVER_ERROR',
        userMessage: 'Our servers are experiencing issues. Please try again in a moment.',
        retryable: true,
        statusCode: 500
      });
    });

    test('handles validation errors correctly', async () => {
      const validationError = new AxiosError('Validation failed');
      validationError.response = {
        status: 400,
        data: { 
          error: 'Validation failed',
          userMessage: 'Please check your input and try again.'
        },
        statusText: 'Bad Request',
        headers: {},
        config: {} as any
      };
      
      mockedAxios.post.mockRejectedValueOnce(validationError);

      const mockInput = { list1: [1], list2: [2, 3] }; // Unequal lengths
      
      await expect(apiClient.calculateDistance(mockInput)).rejects.toMatchObject({
        code: 'VALIDATION_ERROR',
        userMessage: 'Please check your input and try again.',
        retryable: false,
        statusCode: 400
      });
    });
  });

  describe('request interceptors', () => {
    test('adds request metadata to headers', async () => {
      mockedAxios.get.mockResolvedValueOnce({
        data: { status: 'healthy', timestamp: '2025-07-30T12:00:00Z', uptime: 3600 },
        status: 200
      });

      await apiClient.healthCheck();

      expect(mockedAxios.get).toHaveBeenCalledWith('/api/health');
    });
  });

  describe('configuration', () => {
    test('uses environment variables for configuration', () => {
      const originalEnv = process.env;
      
      process.env = {
        ...originalEnv,
        REACT_APP_API_BASE_URL: 'https://api.example.com',
        REACT_APP_API_TIMEOUT: '60000',
        REACT_APP_API_RETRY_ATTEMPTS: '5'
      };

      const client = new ChroniclerApiClient();
      
      // Verify configuration was applied (would need access to private config)
      expect(client).toBeInstanceOf(ChroniclerApiClient);
      
      process.env = originalEnv;
    });
  });
});